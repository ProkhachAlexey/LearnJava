* Глава 6. Введение в классы
Любое понятие, которое требуется реализовать в программе на Java, должно быть инкапсулировано в пределах класса.
** Основы классов
Класс определяет новый тип данных, которым можно воспользоваться для создания объектов данного типа.
Класс - это шаблон для создания объекта, а объект - это экземпляр класса.
*** Общая форма класса
#+begin_src java
class имя_переменной {
    тип переменная_экземпляра1;
    тип переменная_экземпляра2;

    тип имя_метода1(список_параметров) {
        // тело метода;
    }

    тип имя_метода2(список_параметров) {
        // тело метода;
    }
}
#+end_src
Данные или переменные, определенные в классе, называются переменными экземпляра. Код содержится в теле методов.
Переменные экземпляра называются так, поскольку каждый объект класса содержит собственные копии этих переменных. Таким образом данные одного объекта отделены и отличаются от данных другого объекта.
*** Простой класс
#+begin_src java
class Box {
    double width;
    double height;
    double depth;
}
#+end_src
Класс определяет новый тип данных. В данном случае новый тип данных называется Box.
Создание объекта:
#+begin_src java
Box mybox = new Box();
#+end_src
Объект mybox стал экземпляром класса Box.
В объекте класса Box присвоение копий переменным экземпляра width, height и depth произодится через оператор ".":
#+begin_src java
mybox.width = 100;
mybox.height = 200;
mybox.depth = 150;
#+end_src
В общем, оператор "." служит для доступа как к переменным экземпляра, так и к методам в пределах объетка.
Полноценное использование класса Box:
#+begin_src java
class Box {
    double width;
    double height;
    double depth;
}

class BoxDemo {
    public static void main(String args[]) {
        Box mybox = new Box();
        double vol;

        mybox.width = 10;
        mybox.height = 20;
        mybox.depth = 15;
        vol = mybox.width * mybox.height * mybox.depth;
        System.out.println("Объем равен " + vol);
    }
}
#+end_src
** Объявление объектов
Создание объектов класса представляет собой двухэтапный процесс.
Сначала объявляется переменная типа класса. Эта переменная не создает объект. Она является переменной, которая ссылается на объект.
Затем создается физическая копия объекта с присвоением ее переменной, созданной на первом этапе, с помощью оператора new.
Оператор new динамически (во время выполнения) резервирует память для объекта и возвращает ссылку на него.
#+begin_src java
Box mybox;  // объявить ссылку на абстрактный объект
mybox = new Box();  // выделить память для объекта Box
#+end_src
*** Подробное рассмотрение операции new
Общая форма операции имеет вид:
#+begin_src java
переменная_класса = new имя_класса();
#+end_src
имя_класса() - в данном случае является конструктором по умолчанию.
В случае нехватки ОЗУ при работе оператора new возникает исключение времени выполнения (обработка исключений).
В действительности оператор new вызывает конструктор класса.
** Присваивание переменным ссылок на объекты
#+begin_src java
Box b1 = new Box();
Box b2 = b1;
#+end_src
В данном случае переменные b1 и b2 ссылаются на один и тот же объект.
** Введение в методы
Общая форма объявления метода:
#+begin_src java
тип имя(список_параметров) {
    // тело метода
}
#+end_src
Тип метода может быть как допустимым типом данных (int, float ...) так и типом созданного класса.
*** Ввод метода в класс Box
Пример:
#+begin_src java
class Box {
    double width;
    double height;
    double depth;

    void volume() {
        System.out.print("Объем равен ");
        System.out.println(width * height * depth);
    }
}

class BoxDemo {
    public static void main(String[] args) {
        Box mybox1 = new Box();
        Box mybox2 = new Box();

        mybox1.width = 10;
        mybox1.height = 20;
        mybox1.depth = 15;

        mybox2.width = 3;
        mybox2.height = 6;
        mybox2.depth = 9;

        mybox1.volume();
        mybox2.volume();
    }
}
#+end_src
*** Возврат значений
описание оператора return.
*** Ввод метода, принимающего параметры
Параметр - это определенная в методе переменная, которая принимает заданное значение при вызове метода.
Агрумент - это значение, передаваемое методу при его вызове.
#+begin_src java
class Box {
    double width;
    double height;
    double depth;

    double volume() {
        return width * height * depth;
    }

    void setDim(double w, double h, double d) {
        width = w;
        height = h;
        depth = d;
    }
}

class BoxDemo {
    public static void main(String[] args) {
        Box mybox1 = new Box();
        Box mybox2 = new Box();
        mybox1.setDim(10,20,15);
        mybox2.setDim(3,6,9);
        System.out.println("Volume 1 = " + mybox1.volume());
        System.out.println("Volume 2 = " + mybox2.volume());
    }
}
#+end_src
** Конструкторы
Конструктор инициализирует объект при его создании.
Имя конструктора совпадает с именем класса, в котором он находится.
Синтаксис конструктора похож на синтаксис метода, за исключением отсутствия типа возвращаемого значения (даже void).
Это объясняется тем, что неявно заданным возвращаемым типом конструктора класса является тип самого класса.
Пример:
#+begin_src java
class Box {
    double width;
    double height;
    double depth;

    Box() {
        System.out.println("Конструирование объекта Box");
        width = 10;
        height = 10;
        depth = 10;
    }

    double volume() {
        return width * height * depth;
    }
}

class BoxDemo {
    public static void main(String[] args) {
        Box mybox1 = new Box();
        Box mybox2 = new Box();
        double vol;

        vol = mybox1.volume();
        vol = mybox2.volume();
    }
}
#+end_src
Если в классе явно не определено никакого конструктора, то вызывается конструктор по умолчанию.
Конструктор по умолчанию инициализирует все переменные экземпляра установленными по умолчанию значениями.
*** Параметризированные конструкторы
#+begin_src java
class Box {
    double width;
    double height;
    double depth;

    Box(double w, double h, double d) {
        width = w;
        height = h;
        depth = d;
    }

    double volume() {
        return width * height * depth;
    }
}

class BoxDemo {
    public static void main(String[] args) {
        Box mybox1 = new Box(10,20,15);
        Box mybox2 = new Box(3,6,9);
        System.out.println("vol1 = " + mybox1.volume());
        System.out.println("vol2 = " + mybox2.volume());
    }
}
#+end_src
** Ключевое слово this
this - это ссылка на текущий объект, в контексте которого исполяется конструктор/метод.
*** Сокрытие переменных экземпляра
Если имя параметра конструктора/метода совпадает с именем переменной экземпляра, то для доступа к ней используется префикс this.
** Сборка мусора
В отсутствие любых ссылок на объект считается, что этот объект больше не нужен и занимаемую им память можно освободить с помощью процесса "сборка мусора".
** Класс Stack
Рассмотрим организацию стека как один из типичных примеров инкапсуляции:
Данные в стеке хранятся по принципу "первым пришел, последним обнаружен".
Для управлением стеком существует две операции: размещение (в стеке) и извлечение (из стека).
#+begin_src java
class Stack {
    int stck[] = new int[10];
    int tos;

    // инициализация вершины стека
    Stack() {
        tos = -1;
    }

    // размещение элемента в стеке
    void push(int item) {
        if(tos == 9)
            System.out.println("Стек заполнен.");
        else
            stck[++tos] = item;
    }

    // извлечение элемента из стека
    int pop() {
        if(tos < 0) {
            System.out.println("Стек не загружен.");
            return 0;
        }
        else
            return stck[tos--];
    }
}

class TestStack {
    public static void main(String[] args) {
        Stack mystack1 = new Stack();
        Stack mystack2 = new Stack();

        for(int i = 0; i < 10; i++)     mystack1.push(i);
        for(int i = 10; i < 20; i++)    mystack2.push(i);

        System.out.println("Содердимое стека mystack1:");
        for(int i = 0; i < 10; i++)     System.out.println(mystack1.pop());

        System.out.println("Содердимое стека mystack2:");
        for(int i = 0; i < 10; i++)     System.out.println(mystack2.pop());
    }
}
#+end_src

* Глава 7. Подробное рассмотрение классов и методов
** Перегрузка методов
Методы называются перегруженными, а сам процемм называется перегрузкой методов, когда в одном и том же классе находятся два или нескольких методов с одинаковым именем, но обязательно с разным объявлением параметров.
#+begin_src java
class OverloadDemo {
    void test() {
        System.out.println("Параметры отсутствуют");
    }
    void test(int a) {
        System.out.println("a: " + a);
    }
    void test(int a, int b) {
        System.out.println("a и b: " + a + " " + b);
    }
    double test(double a) {
        System.out.println("double a: " + a);
        return a*a;
    }
}

public class Overload {
    public static void main(String[] args) {
        OverloadDemo ob = new OverloadDemo();
        double result;
        ob.test();
        ob.test(10);
        ob.test(10,20);
        result = ob.test(123.25);
        System.out.println(
                "Результат вызова ob.test(123.25): " + result);
    }
}
#+end_src
Важную роль в разрешении перегрузки может играть автоматическое преобразование типов:
#+begin_src java
class OverloadDemo {
    void test() {
        System.out.println("Параметры отсутствуют");
    }
    void test(int a, int b) {
        System.out.println("a и b: " + a + " " + b);
    }
    void test(double a) {
        System.out.println("Внутреннее преобразование при вызове "
        + "test(double) a: " + a);
    }
}

public class Overload {
    public static void main(String[] args) {
        OverloadDemo ob = new OverloadDemo();
        int i = 88;
        ob.test();
        ob.test(10,20);
        ob.test(i);
        ob.test(123.2);
    }
}
#+end_src
Перегрузка методов поддерживает полиморфизм.
На практике следует перегружать только тесно связанные операции.
*** Перегрузка конструкторов
Перегруженный конструктор вызвается в зависимости от переданных в него параметров.
#+begin_src java
class Box {
    double width;
    double height;
    double depth;
    Box(double w, double h, double d) {
        width = w;
        height = h;
        depth = d;
    }
    // Обозначение неинициализированного конструктора
    Box() {
        width = height = depth = -1;
    }
    // Конструктор, используемый при создании куба
    Box(double len) {
        width = height = depth = len;
    }
    // Расчитать и возвратить объем
    double volume() {
        return width * height * depth;
    }
}

public class OverloadCons {
    public static void main(String[] args) {
        Box mybox1 = new Box(10.,20,15);
        Box mybox2 = new Box();
        Box mycube = new Box(7);
    }
}
#+end_src
** Применение объектов в качестве параметров
Пример:
#+begin_src java
class Test {
    int a, b;
    Test(int a, int b) {
        this.a = a;
        this.b = b;
    }
    // Возвратить true в случае равенства двух объектов
    // т.е. сравнение переменных объектов
    boolean equalTo(Test o) {
        if (o.a == a && o.b == b) return true;
        else return false;
    }
}

public class PassOb {
    public static void main(String[] args) {
        Test ob1 = new Test(100, 22);
        Test ob2 = new Test(100, 22);
        Test ob3 = new Test(-1, -1);
        System.out.println("ob1 == ob2: " + ob1.equalTo(ob2));
        System.out.println("ob1 == ob3: " + ob1.equalTo(ob3));
    }
}
#+end_src
Объекты в качестве параметров применяются в конструкторах:
#+begin_src java
class Box {
    double width;
    double height;
    double depth;
    Box(Box ob) {
        width = ob.width;
        height = ob.height;
        depth = ob.depth;
    }
    Box(double width, double height, double depth) {
        this.width = width;
        this.height = height;
        this.depth = depth;
    }
    Box() {
        width = -1;
        height = -1;
        depth = -1;
    }
    Box(double len) {
        width = height = depth = len;
    }
    double volume() {
        return width * height * height;
    }
}

public class OverloadCons2 {
    public static void main(String[] args) {
        Box mybox1 = new Box(10,20,15);
        Box mybox2 = new Box();
        Box mycube = new Box(7);
        Box myclone = new Box(mybox1);
        double vol;
        vol = mybox1.volume();
        System.out.println("Объем mybox1 равен " + vol);
        vol = mybox2.volume();
        System.out.println("Объем mybox2 равен " + vol);
        vol = mycube.volume();
        System.out.println("Объем куба равен " + vol);
        vol = myclone.volume();
        System.out.println("Объем клона равен " + vol);
    }
}
#+end_src
Таким образом, создаются реальные копии объектов с разными ссылками, в отличае от:
#+begin_src java
Box mybox1 = new Box(10,20,15);
Box mybox2 = mybox1;
#+end_src
** Подробное рассмотрение особенностей передачи аргументов
Для передачи аргументов подпрограмме имеется два способа.
Первым способом является вызов по значению. В этом случае значение аргумента копируется в формальный параметр подпрограммы.
Изменения, вносимые в параметр подпрограммы, не оказывают никакого влияния на аргумент.
Вторым способом является вызов по ссылке. В этом случае параметру передается ссылка на аргумент, а не его значение.
В теле подпрограммы эта сслыка служит для обращения к конкретному аргументу, указанному в вызове.
Это означает, что изменения, вносимые в параметр подпрограммы, будут оказывать влияние на аргумент, используемый при ее вызове.
Все аргументы в Java передаются при вызове по значению, но конкретный результат зависит от того, какой именно передается тип данных: примитивный или ссылочный.
Когда методу передается примитивный тип данных, его передача происходит по значению. В итоге создается копия аргумента, и все, что происходит с параметром, принимающим этот аргумент, не оказывает никакого влияния за пределами вызываемого метода.
Пример:
#+begin_src java
class Test {
   void meth(int i, int j) {
      i *= 2;
      j /= 2;
   }
}

public class CallByValue {
   public static void main(String[] args) {
      Test ob = new Test();
      int a = 15, b = 20;
      System.out.println("a = " + a + " b = "  + b);
      ob.meth(a,b);
      System.out.println("a = " + a + " b = "  + b);
   }
}
#+end_src
При передаче объекта в качестве аргумента методу ситуация меняется коренным образом, поскольку объекты передаются при вызове по ссылке.
#+begin_src java
class Test {
   int a, b;
   Test(int i, int j) {
      a = i;
      b = j;
   }
   void meth(Test o) {
      o.a *= 2;
      o.b /= 2;
   }
}

public class CallByValue {
   public static void main(String[] args) {
      Test ob = new Test(15,20);
      System.out.println("a = " + ob.a + " b = "  + ob.b);
      ob.meth(ob);
      System.out.println("a = " + ob.a + " b = "  + ob.b);
   }
}
#+end_src
В данном случае действия, выполняемые в теле метода meth() оказывают влияние на объект, указанный в качестве аргумента.
** Возврат объектов
Метод может возвращать любой тип данных, в том числе созданные типы классов.
#+begin_src java
class Test {
   int a;
   Test(int i) {
      a = i;
   }
   Test incrByTen() {
      Test temp = new Test(a+10);
      return temp;
   }
}

public class CallByValue {
   public static void main(String[] args) {
      Test ob1 = new Test(2);
      Test ob2;
      ob2 = ob1.incrByTen();
      System.out.println("ob1.a: " + ob1.a);
      System.out.println("ob2.a: " + ob2.a);
      ob2 = ob2.incrByTen();
      System.out.println(
            "ob2.a после второго увеличения значения: "
            + ob2.a);
   }
}
#+end_src
При каждом вызове метода incrByTen() создается новый объект, а ссылка на него возвращается вызываемой части программы.
При отсутствии любых ссылок на объект он будет уничтожен при последующей сборке "мусора";
** Рекурсия
Рекурсия это средство, которое позволяет методу вызывать самого себя.
#+begin_src java
class Factorial {
   int fact(int n) {
      int result = 0;
      if (n == 0 || n == 1) return 1;
      result = fact(n - 1) * n;
      return result;
   }
}

public class Recursion {
   public static void main(String[] args) {
      Factorial f = new Factorial();
      System.out.println(f.fact(5));
   }
}
#+end_src
Пример рекрсивного вывода элементов массива на экран:
#+begin_src java
class RecTest {
   int values[];
   RecTest(int i) {
      values = new int[i];
   }

   void printArray(int i) {
      if (i == 0) return;
      else printArray(i - 1);
      System.out.println("[" + (i - 1) + "] " + values[i - 1]);
   }
}

public class Recursion2 {
   public static void main(String[] args) {
      RecTest ob = new RecTest(10);
      int i;
      for (i = 0; i < 10; i++) ob.values[i] = i;
      ob.printArray(10);
   }
}
#+end_src
** Введение в управление доступом
Инкапсуляция связывает данные с манипулирующим ими кодом.
Но инкапсуляция предоставляет еще одно важное средство: управление доступом.
Способ доступа к члену класса определяется модификатором доступа, присутвующем при его объявлении.
Модификаторы: public (публичный), private (закрытый), protected (защищенный). Модификатор protected применяется только при наследовании.
В отсутствие модификатора доступа по умолчанию член класса считается открытым в своем пакете, но недоступным для кода, находящегося за пределами этого пакета.
Как правило, доступ к членам класса приходится ограничивать, предоставляя доступ к ним только через методы.
#+begin_src java
class Test{
   int a;
   public int b;
   private int c;

   void setc(int i) {
      c = i;
   }

   int getc() {
      return c;
   }
}

public class AccessTest {
   public static void main(String[] args) {
      Test ob = new Test();
      ob.a = 10;
      ob.b = 20;
      ob.setc(100);
      System.out.println(ob.getc());
   }
}
#+end_src
Класс Stack из Главы 6
#+begin_src java
class Stack {
   private int stck[] = new int[10];
   private int tos;
   // инициализировать вершину стека
   Stack() {
      tos = -1;
   }
   // разместить элемент в стеке
   void push(int item) {
      if (tos == 9)
         System.out.println("Стек заполнен.");
      else
         stck[++tos] = item;
   }
   // извлечь элемент из стека
   int pop() {
      if (tos < 0) {
         System.out.println("Стек не загружен.");
         return 0;
      }
      else
         return stck[tos--];
   }
}

public class TestStack {
   public static void main(String[] args) {
      Stack mystack1 = new Stack();
      Stack mystack2 = new Stack();
      // разместить числа в стеке
      for (int i = 0; i < 10; i++) mystack1.push(i);
      for (int i = 10; i < 20; i++) mystack2.push(i);
      // извлечь эти числа из стека
      System.out.println("Стек в mystack1:");
      for (int i = 0; i < 10; i++)
         System.out.println(mystack1.pop());

      System.out.println("Стек в mystack2:");
      for (int i = 0; i < 10; i++)
         System.out.println(mystack2.pop());
      // эти операторы недопустимы
      // mystack1.tos. = -2;
      // mystack2.stck[3] = 100;
   }
}
#+end_src
** Ключевое слово static
Для использования переменной экземпляра или метода класса без создания объетка используется static (метод main(), методы стандартных классов).
Переменные экземпляра, объявленные как static, по существу, являются глобальными переменными.
Созданные объкеты используют одну и ту же переменную static.
На методы, объявленные как static, налагаются ограничения:
- они могут вызывать только другие статические методы;
- им доступны только статические переменные;
- они не могут делать ссылки типа this или super.
Можно также объявить статический блок:
#+begin_src java
class UseStatic {
   static int a = 3;
   static int b;

   static void meth(int x) {
      System.out.println("x = " + x);
      System.out.println("a = " + a);
      System.out.println("b = " + b);
   }
   static {
      System.out.println("Статический блок");
      b = a * 4;
   }
   public static void main(String[] args) {
    meth(42);
   }
}
#+end_src
Использование статических переменных или методов за пределами класса:
#+begin_src java
class StaticDemo {
   static int a = 42;
   static int b = 99;

   static void callme() {
      System.out.println("a = " + a);
   }
}

public class StaticByName {
   public static void main(String[] args) {
      StaticDemo.callme();
      System.out.println("b = " + StaticDemo.b);
   }
}
#+end_src
** Ключевое слово final
При использовании final создаются константы.
#+begin_src java
final int FILE_NEW = 1;
final int FILE_OPEN = 2;
final int FILE_SAVE = 3;
final int FILE_SAVEAS = 4;
final int FILE_QUIT = 5;
#+end_src
Кроме полей, объявленными как final могут быть параметры метода и локальные переменные.
Это препядствует изменению параметра метода, тогда как аналогичное объявление локальной переменной - присвоению ей значения больше одного раза.
Ключевое слово final можно указывать и в объявлении методов. В данном случае это имеет совсем другое значение (что-то с наследованием).
** Еще раз о массивах
Размер массива хранится в его переменной экземпляра legth:
#+begin_src java
public class Length {
   public static void main(String[] args) {
      int a1[] = new int[10];
      int a2[] = {3,5,7,1,8,99,44,-10};
      int a3[] = {4,3,2,1};
      System.out.println("длина а1 равна " + a1.length);
      System.out.println("длина а2 равна " + a2.length);
      System.out.println("длина а3 равна " + a3.length);
   }
}
#+end_src
** Вложенные и внутренние классы
Вложенным называется класс, расположенный внутри другого класса.
Область действия вложенного класса ограничивается областью действия внешнего класса.
Вложенный класс имеет доступ к членам (в т.ч. закрытым) того класса, в который он вложен.
Но внешний класс не имеет доступа к членам вложенного класса.
Типы вложенных классов: статические и нестатические.
Статический вложенный класс объявляется при помощи static, и он должен обращаться только к статическим членам своего внешнего класса посредством объекта.
Внутренний класс - это нестатический вложенный класс. Он имеет доступ ко всем переменным и методам своего внешнего класса.
#+begin_src java
class Outer {
   int outer_x = 100;
   void test() {
      Inner inner = new Inner();
      inner.display();
   }

   class Inner {
      void display() {
         System.out.println("вывод: outer_x = " + outer_x);
      }
   }
}

public class InnerClassDemo {
   public static void main(String[] args) {
      Outer outer = new Outer();
      outer.test();
   }
}
#+end_src
Вложенные классы удобно использовать при обработке событий (глава 24).
** Краткий обзор класса String
Любая символьная строка как и строковая константа являются объектом класса String.
Объекты класса String являются неизменяемыми.
Если нужно изменить строку, то:
- можно создать новую;
- можно воспользоваться классами StringBuffer или StringBuilder.
#+begin_src java
public class StringDemo {
   public static void main(String[] args) {
      String strOb1 = "Первая строка";
      String strOb2 = "Вторая строка";
      String strOb3 = strOb1 + " и " + strOb2;
      System.out.println(strOb1);
      System.out.println(strOb2);
      System.out.println(strOb3);
   }
}
#+end_src
Некоторые методы класса String:
equals() - проверка двух символьных строк на равенство;
length() - вычисление длины символьной строки;
charAt() - получение символа по заданному индексу.
Общие формы:
#+begin_src java
boolean equals(вторая_строка);
int length();
char charAt(индекс);
#+end_src
Ситкаксис:
#+begin_src java
public class StringDemo {
   public static void main(String[] args) {
      String strOb1 = "Первая строка";
      String strOb2 = "Вторая строка";
      String strOb3 = strOb1;
      System.out.println("Длина строки strOb1: " + strOb1.length());
      System.out.println("Символ по индексу 3 " + " в строке strOb1: " + strOb1.charAt(3));
      if (strOb1.equals(strOb2))
         System.out.println("strOb1 == strOb2");
      else
         System.out.println("strOb1 != strOb2");
      if (strOb1.equals(strOb3))
         System.out.println("strOb1 == strOb3");
      else
         System.out.println("strOb1 != strOb3");
   }
}
#+end_src
Массивы символьных строк:
#+begin_src java
public class StringDemo {
   public static void main(String[] args) {
      String str[] = {"один", "два", "три"};
      for (int i = 0; i < str.length; i++)
         System.out.println("str[" + i + "]: " + str[i]);
   }
}
#+end_src
** Применение аргуметов командной строки
Аргумент командной строки - информация, которая во время запуска программы указывается в командной строке непосредственно после ее имени.
Аргументы командной строки хранятся в виде симольных строк в массиве типа String.
Первый аргумент командной строки хранится в элементе массива args[0], второй в элементе args[1] и т.д.
Вывод всех аргументы командной строки:
#+begin_src java
public class StringDemo {
   public static void main(String[] args) {
      for (int i = 0; i < args.length; i++)
         System.out.println("args[" + i + "]: " + args[i]);
   }
}
#+end_src
** Аргументы переменной длины
В версии JDK5 было внедрено новое языковое средство, упрощающее создание методов, принимающих переменное количество аргументов.
Оно получило название varargs (variable-length arguments - аргементы переменной длины).
До версии J2SE 5 обработка аргументов переменной длины выполнялась двумя способами:
1. Перегрузка методов;
2. Аргументы сначала размещаются в массиве, а затем массив передается методу.
   Пример:
#+begin_src java
public class PassArray {
   static void vaTest(int v[]) {
      System.out.print("Количество аргументов: " + v.length + " Содержимое: ");
      for (int x : v)
         System.out.print(x + " ");
      System.out.println();
   }

   public static void main(String[] args) {
      int n1[] = {10};
      int n2[] = {1,2,3};
      int n3[] = { };
      vaTest(n1);
      vaTest(n2);
      vaTest(n3);
   }
}
#+end_src
Этот подход требует ручного размещения аргументов в массиве до вызова методов.
Для указания аргументов переменной длины служат три точки (...)
#+begin_src java
static void vaTest(int ... v) {
#+end_src
Таким образом методу можно передавить переменной количество аргументов или вообще ничего не передаваться.
В итоге массив v неявно объявляется как массив типа int[].
В теле метода vaTest() доступ к массиву v осуществляется через синтаксим обычного массива.
#+begin_src java
public class VarArgs {
   static void vaTest(int ... v) {
      System.out.print("Количество аргументов: " + v.length + " Содержимое: ");
      for (int x : v)
         System.out.print(x + " ");
      System.out.println();
   }

   public static void main(String[] args) {
      vaTest(10);
      vaTest(1,2,3);
      vaTest();
   }
}
#+end_src
Наряду с параметрами переменной длины у метода могут быть и обычные параметры.
Но параметр переменной длины должен быть последним:
#+begin_src java
int doIt(int a, double b, int ... c) {
#+end_src
Метод должен содержать только один параметр с переменным количеством аргументов.
*** Перегрузка методов с аргументами переменной длины
Метод, принимающий аргументы переменной длины, можно перегружать.
#+begin_src java
public class VarArgs3 {
   static void vaTest(int ... v) {
      System.out.print("vaTest(int ...): "
            + "Количесвто аргументов: "
            + v.length + " Содержимое: ");
      for (int x : v)
         System.out.print(x + " ");
      System.out.println();
   }

   static void vaTest(boolean ... v) {
      System.out.print("vaTest(boolean ...): "
            + "Количесвто аргументов: "
            + v.length + " Содержимое: ");
      for (boolean x : v)
         System.out.print(x + " ");
      System.out.println();
   }

   static void vaTest(String msg, int ... v) {
      System.out.print("vaTest(String, int ...): "
            + msg + v.length + " Содержимое: ");
      for (int x : v)
         System.out.print(x + " ");
      System.out.println();
   }

   public static void main(String[] args) {
      vaTest(1,2,3);
      vaTest("Проверка", 10, 20);
      vaTest(true, false);
   }
}
#+end_src
*** Аргументы переменной длины и неоднозначность
При перегрузке метода, принимающего аргументы переменной длины, могут происходить непредвиденные ошибки.
Они связаны с неоднозначностью, которая может возникать при вызове перегружаемого метода с аргументами переменной длины.
#+begin_src java
public class StringDemo {
   static void vaTest(int ... v) {
      System.out.print("vaTest(int ...): "
            + "Количесвто аргументов: "
            + v.length + " Содержимое: ");
      for (int x : v)
         System.out.print(x + " ");
      System.out.println();
   }

   static void vaTest(boolean ... v) {
      System.out.print("vaTest(boolean ...): "
            + "Количесвто аргументов: "
            + v.length + " Содержимое: ");
      for (boolean x : v)
         System.out.print(x + " ");
      System.out.println();
   }

   public static void main(String[] args) {
      vaTest(1,2,3);
      vaTest(true, false);
      vaTest(); // ERROR!!!
   }
}
#+end_src
Еще один пример неоднозначности:
#+begin_src java
static void vaTest(int ... v) { // ...
static void vaTest(int n, int ... v) { // ...
#+end_src
Компилятор не в состоянии разрешить следующий вызов:
#+begin_src java
vaTest(1);
#+end_src

* Глава 8. Наследование
Наследуемый класс называется суперклассом, а наследующий - подклассом.
Подкласс - это специализированная версия суперкласса. Он наследует все члены, определенные в суперклассе, добавляя к ним собственные элементы.
** Основы наследования
Ключевое слово extends для наследования класса.
Общая форма наследования:
#+begin_src java
class имя_подкласса extends имя_суперкласса {
    // тело класса
}
#+end_src
#+begin_src java
class A {
   int i, j;
   void showij() {
      System.out.println("i и j: " + i + " " + j);
   }
}
class B extends A {
   int k;
   void showk() {
      System.out.println("k: " + k);
   }
   void sum() {
      System.out.println("i+j+k: " + (i+j+k));
   }
}
public class SimpleInheritance {
   public static void main(String[] args) {
      A superOb = new A();
      B subOb = new B();
      // суперкласс может использоваться самостоятельно
      superOb.i = 10;
      superOb.j = 20;
      System.out.println("Содержимое объекта superOb: ");
      superOb.showij();
      System.out.println();
      /*Подкласс имеет доступ ко всем открытым членам своего суперкласса*/
      subOb.i = 7;
      subOb.j = 8;
      subOb.k = 9;
      System.out.println("Содержимое объекта subOb: ");
      subOb.showij();
      subOb.showk();
      System.out.println();
      System.out.println("Сумма i, j и k в объекте subOb: ");
      subOb.sum();
   }
}
#+end_src
*** Доступ к членам класса и наследование
Подкласс не имеет доступ к членам суперкласса, объявленных как private.
#+begin_src java
class A {
   int i;
   private int j;
   void showij(int x, int y) {
      i = x;
      j = y;
   }
}
class B extends A {
   int total;
   void sum() {
      total = i + j; // ERROR!!!
   }
}
public class Access {
   public static void main(String[] args) {
      B subOb = new B();
      subOb.setij(10,20); // ERROR!!!
      subOb.sum();
      System.out.println("Сумма равна " + subOb.total);
   }
}
#+end_src
*** Практический пример наследования
#+begin_src java
class Box {
   double width;
   double height;
   double depth;
   // клон объекта
   Box(Box ob) {
      width = ob.width;
      height = ob.height;
      depth = ob.depth;
   }
   // все размеры
   Box(double w, double h, double d) {
      width = w;
      height = h;
      depth = d;
   }
   // отсутствие размеров
   Box() {
      width = -1;
      height = -1;
      depth = -1;
   }
   // куб
   Box(double len) {
      width = height = depth = len;
   }
   // расчет и возврат объема
   double volume() {
      return width * height * depth;
   }
}
class BoxWeight extends Box {
   double weight;
   BoxWeight(double w, double h, double d, double m) {
      width = w;
      height = h;
      depth = d;
      weight = m;
   }
}
public class DemoBoxWeight {
   public static void main(String[] args) {
      BoxWeight mybox1 = new BoxWeight(10,20,15,34.3);
      BoxWeight mybox2 = new BoxWeight(2,3,4,0.076);
      double vol;
      vol = mybox1.volume();
      System.out.println(vol);
      System.out.println(mybox1.weight);
      vol = mybox2.volume();
      System.out.println(vol);
      System.out.println(mybox2.weight);
   }
}
#+end_src
*** Переменная из суперкласса может ссылаться на объект подкласса
Ссылочной переменной из суперкласса может быть присвоена ссылка на любой подкласс, производный от этого суперкласса.
#+begin_src java
public class DemoBoxWeight {
   public static void main(String[] args) {
      BoxWeight weightbox = new BoxWeight(3,5,7,8.37);
      Box plainbox = new Box();
      double vol;
      vol = weightbox.volume();
      System.out.println("Объем weightbox равен " + vol);
      System.out.println("Вес weightbox раве " + weightbox.weight);
      // присвоить переменной ссылки на объект типа BoxWeight
      // ссылку на объект типа Box
      plainbox = weightbox;
      vol = plainbox.volume(); // Верно, т.к. метод volume()
                              // определен в классе Box
      System.out.println("Объем plainbox равен " + vol);
      /*Следующий оператор ошибочен, поскольку член plainbox
      * не определяет член weight*/
      System.out.println("Вес plainbox равер " + plainbox.weight);
   }
}
#+end_src
Объекту типа суперкласса (plainbox) можно присвоить ссылку на объект типа подкласса (weightbox).
** Ключевое слово super
С помощью ключевого слова super подклассу представляется возможность сосласться на его непосредственный суперкласс.
У ключевого слова super имеются две общие формы. Первая форма служит для вызова конструктора суперкласса.
Вторая - для обращения к члену суперкласса, скрываемому членом подкласса.
*** Вызов конструкторов суперкласса и помощью ключевого слова super
Из подкласса можно вызвать конструктор, определенный в его суперклассе:
#+begin_src java
super(список_аргументов);
#+end_src
Вызов super(); дожен находиться в первом операторе, выполняемом в конструкторе подкласса.
#+begin_src java
class BoxWeight extends Box {
   double weight;
   BoxWeight(double w, double h, double d, double m) {
      super(w,h,d);
      weight = m;
   }
}
#+end_src
Конструкторы могут быть перегружаемыми, поэтому метод super() можно вызывать, используя любую форму, определенную в суперклассе.
#+begin_src java
class Box {
   private double width;
   private double height;
   private double depth;
   // клон объекта
   Box(Box ob) {
      width = ob.width;
      height = ob.height;
      depth = ob.depth;
   }
   // все размеры
   Box(double w, double h, double d) {
      width = w;
      height = h;
      depth = d;
   }
   // отсутствие размеров
   Box() {
      width = -1;
      height = -1;
      depth = -1;
   }
   // куб
   Box(double len) {
      width = height = depth = len;
   }
   // расчет и возврат объема
   double volume() {
      return width * height * depth;
   }
}
class BoxWeight extends Box {
   double weight;
   // сконструировать клон объекта
   BoxWeight(BoxWeight ob) {
      super(ob);
      weight = ob.weight;
   }
   // все параметры
   BoxWeight(double w, double h, double d, double m) {
      super(w,h,d);
      weight = m;
   }
   // конструктор по умолчанию
   BoxWeight() {
      super();
      weight = -1;
   }
   // конструктор для куба
   BoxWeight(double len, double m) {
      super(len);
      weight = m;
   }
}
#+end_src
Несмотря на то, что методу super() передается объект типа BoxWeight, а не Box, это все равно приводить к вызову конструктора Box(Box.ob).
#+begin_src java
BoxWeight(BoxWeight ob) {
   super(ob);
   weight = ob.weight;
}
#+end_src
При вызове метода super() из подкласса вызывается конструктор его непосредственного суперкласса (на один выше).
Это справледливо также для многоуровневой иерархии.
*** Другое применение ключевого слова super
Вторая форма ключевого слова super действует подобно ключевому слову this, за исключением того, что ссылка всегда делается на суперкласс того подкласса, в котором используется super.
Общая форма применения:
#+begin_src java
super.член // член - переменная экземпляра или метод
#+end_src
Применяется когда имена членов подкласса скрывают члены суперкласса с такими же именами.
#+begin_src java
class A {
   int i;
}

class B extends A {
   int i; // этот член i  скрывает член i из класса А

   B(int a, int b) {
      super.i = a;   // член i  из класса А
      i = b;         // член i  из класса В
   }
   void show() {
      System.out.println("Член i в суперклассе: " + super.i);
      System.out.println("Член i в подклассе: " + i);
   }
}

public class UseSuper {
   public static void main(String[] args) {
      B subOb = new B(1,2);
      subOb.show();
   }
}
#+end_src
** Создание многоуровневой иерархии
** Порядок вызова конструкторов
** Переопределение методов
** Динамическая диспетчеризация методов
*** Назначение переопределенных методов
*** Применение переопределенных методов
** Применение абстрактных классов
** Ключевое слово final в сочетании с наследованием
*** Предотвращение переопределения с помощью ключевого слова final
*** Предотвращение наследования с помощью ключевого слова final
** Класс Object
