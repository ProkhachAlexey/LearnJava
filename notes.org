* Глава 6. Введение в классы
Любое понятие, которое требуется реализовать в программе на Java, должно быть инкапсулировано в пределах класса.
** Основы классов
Класс определяет новый тип данных, которым можно воспользоваться для создания объектов данного типа.
Класс - это шаблон для создания объекта, а объект - это экземпляр класса.
*** Общая форма класса
#+begin_src java
class имя_переменной {
    тип переменная_экземпляра1;
    тип переменная_экземпляра2;

    тип имя_метода1(список_параметров) {
        // тело метода;
    }

    тип имя_метода2(список_параметров) {
        // тело метода;
    }
}
#+end_src
Данные или переменные, определенные в классе, называются переменными экземпляра. Код содержится в теле методов.
Переменные экземпляра называются так, поскольку каждый объект класса содержит собственные копии этих переменных. Таким образом данные одного объекта отделены и отличаются от данных другого объекта.
*** Простой класс
#+begin_src java
class Box {
    double width;
    double height;
    double depth;
}
#+end_src
Класс определяет новый тип данных. В данном случае новый тип данных называется Box.
Создание объекта:
#+begin_src java
Box mybox = new Box();
#+end_src
Объект mybox стал экземпляром класса Box.
В объекте класса Box присвоение копий переменным экземпляра width, height и depth произодится через оператор ".":
#+begin_src java
mybox.width = 100;
mybox.height = 200;
mybox.depth = 150;
#+end_src
В общем, оператор "." служит для доступа как к переменным экземпляра, так и к методам в пределах объетка.
Полноценное использование класса Box:
#+begin_src java
class Box {
    double width;
    double height;
    double depth;
}

class BoxDemo {
    public static void main(String args[]) {
        Box mybox = new Box();
        double vol;

        mybox.width = 10;
        mybox.height = 20;
        mybox.depth = 15;
        vol = mybox.width * mybox.height * mybox.depth;
        System.out.println("Объем равен " + vol);
    }
}
#+end_src
** Объявление объектов
Создание объектов класса представляет собой двухэтапный процесс.
Сначала объявляется переменная типа класса. Эта переменная не создает объект. Она является переменной, которая ссылается на объект.
Затем создается физическая копия объекта с присвоением ее переменной, созданной на первом этапе, с помощью оператора new.
Оператор new динамически (во время выполнения) резервирует память для объекта и возвращает ссылку на него.
#+begin_src java
Box mybox;  // объявить ссылку на абстрактный объект
mybox = new Box();  // выделить память для объекта Box
#+end_src
*** Подробное рассмотрение операции new
Общая форма операции имеет вид:
#+begin_src java
переменная_класса = new имя_класса();
#+end_src
имя_класса() - в данном случае является конструктором по умолчанию.
В случае нехватки ОЗУ при работе оператора new возникает исключение времени выполнения (обработка исключений).
В действительности оператор new вызывает конструктор класса.
** Присваивание переменным ссылок на объекты
#+begin_src java
Box b1 = new Box();
Box b2 = b1;
#+end_src
В данном случае переменные b1 и b2 ссылаются на один и тот же объект.
** Введение в методы
Общая форма объявления метода:
#+begin_src java
тип имя(список_параметров) {
    // тело метода
}
#+end_src
Тип метода может быть как допустимым типом данных (int, float ...) так и типом созданного класса.
*** Ввод метода в класс Box
Пример:
#+begin_src java
class Box {
    double width;
    double height;
    double depth;

    void volume() {
        System.out.print("Объем равен ");
        System.out.println(width * height * depth);
    }
}

class BoxDemo {
    public static void main(String[] args) {
        Box mybox1 = new Box();
        Box mybox2 = new Box();

        mybox1.width = 10;
        mybox1.height = 20;
        mybox1.depth = 15;

        mybox2.width = 3;
        mybox2.height = 6;
        mybox2.depth = 9;

        mybox1.volume();
        mybox2.volume();
    }
}
#+end_src
*** Возврат значений
описание оператора return.
*** Ввод метода, принимающего параметры
Параметр - это определенная в методе переменная, которая принимает заданное значение при вызове метода.
Агрумент - это значение, передаваемое методу при его вызове.
#+begin_src java
class Box {
    double width;
    double height;
    double depth;

    double volume() {
        return width * height * depth;
    }

    void setDim(double w, double h, double d) {
        width = w;
        height = h;
        depth = d;
    }
}

class BoxDemo {
    public static void main(String[] args) {
        Box mybox1 = new Box();
        Box mybox2 = new Box();
        mybox1.setDim(10,20,15);
        mybox2.setDim(3,6,9);
        System.out.println("Volume 1 = " + mybox1.volume());
        System.out.println("Volume 2 = " + mybox2.volume());
    }
}
#+end_src
** Конструкторы
Конструктор инициализирует объект при его создании.
Имя конструктора совпадает с именем класса, в котором он находится.
Синтаксис конструктора похож на синтаксис метода, за исключением отсутствия типа возвращаемого значения (даже void).
Это объясняется тем, что неявно заданным возвращаемым типом конструктора класса является тип самого класса.
Пример:
#+begin_src java
class Box {
    double width;
    double height;
    double depth;

    Box() {
        System.out.println("Конструирование объекта Box");
        width = 10;
        height = 10;
        depth = 10;
    }

    double volume() {
        return width * height * depth;
    }
}

class BoxDemo {
    public static void main(String[] args) {
        Box mybox1 = new Box();
        Box mybox2 = new Box();
        double vol;

        vol = mybox1.volume();
        vol = mybox2.volume();
    }
}
#+end_src
Если в классе явно не определено никакого конструктора, то вызывается конструктор по умолчанию.
Конструктор по умолчанию инициализирует все переменные экземпляра установленными по умолчанию значениями.
*** Параметризированные конструкторы
#+begin_src java
class Box {
    double width;
    double height;
    double depth;

    Box(double w, double h, double d) {
        width = w;
        height = h;
        depth = d;
    }

    double volume() {
        return width * height * depth;
    }
}

class BoxDemo {
    public static void main(String[] args) {
        Box mybox1 = new Box(10,20,15);
        Box mybox2 = new Box(3,6,9);
        System.out.println("vol1 = " + mybox1.volume());
        System.out.println("vol2 = " + mybox2.volume());
    }
}
#+end_src
** Ключевое слово this
this - это ссылка на текущий объект, в контексте которого исполяется конструктор/метод.
*** Сокрытие переменных экземпляра
Если имя параметра конструктора/метода совпадает с именем переменной экземпляра, то для доступа к ней используется префикс this.
** Сборка мусора
В отсутствие любых ссылок на объект считается, что этот объект больше не нужен и занимаемую им память можно освободить с помощью процесса "сборка мусора".
** Класс Stack
Рассмотрим организацию стека как один из типичных примеров инкапсуляции:
Данные в стеке хранятся по принципу "первым пришел, последним обнаружен".
Для управлением стеком существует две операции: размещение (в стеке) и извлечение (из стека).
#+begin_src java
class Stack {
    int stck[] = new int[10];
    int tos;

    // инициализация вершины стека
    Stack() {
        tos = -1;
    }

    // размещение элемента в стеке
    void push(int item) {
        if(tos == 9)
            System.out.println("Стек заполнен.");
        else
            stck[++tos] = item;
    }

    // извлечение элемента из стека
    int pop() {
        if(tos < 0) {
            System.out.println("Стек не загружен.");
            return 0;
        }
        else
            return stck[tos--];
    }
}

class TestStack {
    public static void main(String[] args) {
        Stack mystack1 = new Stack();
        Stack mystack2 = new Stack();

        for(int i = 0; i < 10; i++)     mystack1.push(i);
        for(int i = 10; i < 20; i++)    mystack2.push(i);

        System.out.println("Содердимое стека mystack1:");
        for(int i = 0; i < 10; i++)     System.out.println(mystack1.pop());

        System.out.println("Содердимое стека mystack2:");
        for(int i = 0; i < 10; i++)     System.out.println(mystack2.pop());
    }
}
#+end_src

* Глава 7. Подробное рассмотрение классов и методов
** Перегрузка методов
Методы называются перегруженными, а сам процемм называется перегрузкой методов, когда в одном и том же классе находятся два или нескольких методов с одинаковым именем, но обязательно с разным объявлением параметров.
#+begin_src java
class OverloadDemo {
    void test() {
        System.out.println("Параметры отсутствуют");
    }
    void test(int a) {
        System.out.println("a: " + a);
    }
    void test(int a, int b) {
        System.out.println("a и b: " + a + " " + b);
    }
    double test(double a) {
        System.out.println("double a: " + a);
        return a*a;
    }
}

public class Overload {
    public static void main(String[] args) {
        OverloadDemo ob = new OverloadDemo();
        double result;
        ob.test();
        ob.test(10);
        ob.test(10,20);
        result = ob.test(123.25);
        System.out.println(
                "Результат вызова ob.test(123.25): " + result);
    }
}
#+end_src
Важную роль в разрешении перегрузки может играть автоматическое преобразование типов:
#+begin_src java
class OverloadDemo {
    void test() {
        System.out.println("Параметры отсутствуют");
    }
    void test(int a, int b) {
        System.out.println("a и b: " + a + " " + b);
    }
    void test(double a) {
        System.out.println("Внутреннее преобразование при вызове "
        + "test(double) a: " + a);
    }
}

public class Overload {
    public static void main(String[] args) {
        OverloadDemo ob = new OverloadDemo();
        int i = 88;
        ob.test();
        ob.test(10,20);
        ob.test(i);
        ob.test(123.2);
    }
}
#+end_src
Перегрузка методов поддерживает полиморфизм.
На практике следует перегружать только тесно связанные операции.
*** Перегрузка конструкторов
Перегруженный конструктор вызвается в зависимости от переданных в него параметров.
#+begin_src java
class Box {
    double width;
    double height;
    double depth;
    Box(double w, double h, double d) {
        width = w;
        height = h;
        depth = d;
    }
    // Обозначение неинициализированного конструктора
    Box() {
        width = height = depth = -1;
    }
    // Конструктор, используемый при создании куба
    Box(double len) {
        width = height = depth = len;
    }
    // Расчитать и возвратить объем
    double volume() {
        return width * height * depth;
    }
}

public class OverloadCons {
    public static void main(String[] args) {
        Box mybox1 = new Box(10.,20,15);
        Box mybox2 = new Box();
        Box mycube = new Box(7);
    }
}
#+end_src
** Применение объектов в качестве параметров
Пример:
#+begin_src java
class Test {
    int a, b;
    Test(int a, int b) {
        this.a = a;
        this.b = b;
    }
    // Возвратить true в случае равенства двух объектов
    // т.е. сравнение переменных объектов
    boolean equalTo(Test o) {
        if (o.a == a && o.b == b) return true;
        else return false;
    }
}

public class PassOb {
    public static void main(String[] args) {
        Test ob1 = new Test(100, 22);
        Test ob2 = new Test(100, 22);
        Test ob3 = new Test(-1, -1);
        System.out.println("ob1 == ob2: " + ob1.equalTo(ob2));
        System.out.println("ob1 == ob3: " + ob1.equalTo(ob3));
    }
}
#+end_src
Объекты в качестве параметров применяются в конструкторах:
#+begin_src java
class Box {
    double width;
    double height;
    double depth;
    Box(Box ob) {
        width = ob.width;
        height = ob.height;
        depth = ob.depth;
    }
    Box(double width, double height, double depth) {
        this.width = width;
        this.height = height;
        this.depth = depth;
    }
    Box() {
        width = -1;
        height = -1;
        depth = -1;
    }
    Box(double len) {
        width = height = depth = len;
    }
    double volume() {
        return width * height * height;
    }
}

public class OverloadCons2 {
    public static void main(String[] args) {
        Box mybox1 = new Box(10,20,15);
        Box mybox2 = new Box();
        Box mycube = new Box(7);
        Box myclone = new Box(mybox1);
        double vol;
        vol = mybox1.volume();
        System.out.println("Объем mybox1 равен " + vol);
        vol = mybox2.volume();
        System.out.println("Объем mybox2 равен " + vol);
        vol = mycube.volume();
        System.out.println("Объем куба равен " + vol);
        vol = myclone.volume();
        System.out.println("Объем клона равен " + vol);
    }
}
#+end_src
Таким образом, создаются реальные копии объектов с разными ссылками, в отличае от:
#+begin_src java
Box mybox1 = new Box(10,20,15);
Box mybox2 = mybox1;
#+end_src
** Подробное рассмотрение особенностей передачи аргументов
Для передачи аргументов подпрограмме имеется два способа.
Первым способом является вызов по значению. В этом случае значение аргумента копируется в формальный параметр подпрограммы.
Изменения, вносимые в параметр подпрограммы, не оказывают никакого влияния на аргумент.
Вторым способом является вызов по ссылке. В этом случае параметру передается ссылка на аргумент, а не его значение.
В теле подпрограммы эта сслыка служит для обращения к конкретному аргументу, указанному в вызове.
Это означает, что изменения, вносимые в параметр подпрограммы, будут оказывать влияние на аргумент, используемый при ее вызове.
Все аргументы в Java передаются при вызове по значению, но конкретный результат зависит от того, какой именно передается тип данных: примитивный или ссылочный.
Когда методу передается примитивный тип данных, его передача происходит по значению. В итоге создается копия аргумента, и все, что происходит с параметром, принимающим этот аргумент, не оказывает никакого влияния за пределами вызываемого метода.
Пример:
#+begin_src java
class Test {
   void meth(int i, int j) {
      i *= 2;
      j /= 2;
   }
}

public class CallByValue {
   public static void main(String[] args) {
      Test ob = new Test();
      int a = 15, b = 20;
      System.out.println("a = " + a + " b = "  + b);
      ob.meth(a,b);
      System.out.println("a = " + a + " b = "  + b);
   }
}
#+end_src
При передаче объекта в качестве аргумента методу ситуация меняется коренным образом, поскольку объекты передаются при вызове по ссылке.
#+begin_src java
class Test {
   int a, b;
   Test(int i, int j) {
      a = i;
      b = j;
   }
   void meth(Test o) {
      o.a *= 2;
      o.b /= 2;
   }
}

public class CallByValue {
   public static void main(String[] args) {
      Test ob = new Test(15,20);
      System.out.println("a = " + ob.a + " b = "  + ob.b);
      ob.meth(ob);
      System.out.println("a = " + ob.a + " b = "  + ob.b);
   }
}
#+end_src
В данном случае действия, выполняемые в теле метода meth() оказывают влияние на объект, указанный в качестве аргумента.
** Возврат объектов
Метод может возвращать любой тип данных, в том числе созданные типы классов.
#+begin_src java
class Test {
   int a;
   Test(int i) {
      a = i;
   }
   Test incrByTen() {
      Test temp = new Test(a+10);
      return temp;
   }
}

public class CallByValue {
   public static void main(String[] args) {
      Test ob1 = new Test(2);
      Test ob2;
      ob2 = ob1.incrByTen();
      System.out.println("ob1.a: " + ob1.a);
      System.out.println("ob2.a: " + ob2.a);
      ob2 = ob2.incrByTen();
      System.out.println(
            "ob2.a после второго увеличения значения: "
            + ob2.a);
   }
}
#+end_src
При каждом вызове метода incrByTen() создается новый объект, а ссылка на него возвращается вызываемой части программы.
При отсутствии любых ссылок на объект он будет уничтожен при последующей сборке "мусора";
** Рекурсия
Рекурсия это средство, которое позволяет методу вызывать самого себя.
#+begin_src java
class Factorial {
   int fact(int n) {
      int result = 0;
      if (n == 0 || n == 1) return 1;
      result = fact(n - 1) * n;
      return result;
   }
}

public class Recursion {
   public static void main(String[] args) {
      Factorial f = new Factorial();
      System.out.println(f.fact(5));
   }
}
#+end_src
Пример рекрсивного вывода элементов массива на экран:
#+begin_src java
class RecTest {
   int values[];
   RecTest(int i) {
      values = new int[i];
   }

   void printArray(int i) {
      if (i == 0) return;
      else printArray(i - 1);
      System.out.println("[" + (i - 1) + "] " + values[i - 1]);
   }
}

public class Recursion2 {
   public static void main(String[] args) {
      RecTest ob = new RecTest(10);
      int i;
      for (i = 0; i < 10; i++) ob.values[i] = i;
      ob.printArray(10);
   }
}
#+end_src
** Введение в управление доступом
Инкапсуляция связывает данные с манипулирующим ими кодом.
Но инкапсуляция предоставляет еще одно важное средство: управление доступом.
Способ доступа к члену класса определяется модификатором доступа, присутвующем при его объявлении.
Модификаторы: public (публичный), private (закрытый), protected (защищенный). Модификатор protected применяется только при наследовании.
В отсутствие модификатора доступа по умолчанию член класса считается открытым в своем пакете, но недоступным для кода, находящегося за пределами этого пакета.
Как правило, доступ к членам класса приходится ограничивать, предоставляя доступ к ним только через методы.
#+begin_src java
class Test{
   int a;
   public int b;
   private int c;

   void setc(int i) {
      c = i;
   }

   int getc() {
      return c;
   }
}

public class AccessTest {
   public static void main(String[] args) {
      Test ob = new Test();
      ob.a = 10;
      ob.b = 20;
      ob.setc(100);
      System.out.println(ob.getc());
   }
}
#+end_src
Класс Stack из Главы 6
#+begin_src java
class Stack {
   private int stck[] = new int[10];
   private int tos;
   // инициализировать вершину стека
   Stack() {
      tos = -1;
   }
   // разместить элемент в стеке
   void push(int item) {
      if (tos == 9)
         System.out.println("Стек заполнен.");
      else
         stck[++tos] = item;
   }
   // извлечь элемент из стека
   int pop() {
      if (tos < 0) {
         System.out.println("Стек не загружен.");
         return 0;
      }
      else
         return stck[tos--];
   }
}

public class TestStack {
   public static void main(String[] args) {
      Stack mystack1 = new Stack();
      Stack mystack2 = new Stack();
      // разместить числа в стеке
      for (int i = 0; i < 10; i++) mystack1.push(i);
      for (int i = 10; i < 20; i++) mystack2.push(i);
      // извлечь эти числа из стека
      System.out.println("Стек в mystack1:");
      for (int i = 0; i < 10; i++)
         System.out.println(mystack1.pop());

      System.out.println("Стек в mystack2:");
      for (int i = 0; i < 10; i++)
         System.out.println(mystack2.pop());
      // эти операторы недопустимы
      // mystack1.tos. = -2;
      // mystack2.stck[3] = 100;
   }
}
#+end_src
** Ключевое слово static
Для использования переменной экземпляра или метода класса без создания объетка используется static (метод main(), методы стандартных классов).
Переменные экземпляра, объявленные как static, по существу, являются глобальными переменными.
Созданные объкеты используют одну и ту же переменную static.
На методы, объявленные как static, налагаются ограничения:
- они могут вызывать только другие статические методы;
- им доступны только статические переменные;
- они не могут делать ссылки типа this или super.
Можно также объявить статический блок:
#+begin_src java
class UseStatic {
   static int a = 3;
   static int b;

   static void meth(int x) {
      System.out.println("x = " + x);
      System.out.println("a = " + a);
      System.out.println("b = " + b);
   }
   static {
      System.out.println("Статический блок");
      b = a * 4;
   }
   public static void main(String[] args) {
    meth(42);
   }
}
#+end_src
Использование статических переменных или методов за пределами класса:
#+begin_src java
class StaticDemo {
   static int a = 42;
   static int b = 99;

   static void callme() {
      System.out.println("a = " + a);
   }
}

public class StaticByName {
   public static void main(String[] args) {
      StaticDemo.callme();
      System.out.println("b = " + StaticDemo.b);
   }
}
#+end_src
** Ключевое слово final
При использовании final создаются константы.
#+begin_src java
final int FILE_NEW = 1;
final int FILE_OPEN = 2;
final int FILE_SAVE = 3;
final int FILE_SAVEAS = 4;
final int FILE_QUIT = 5;
#+end_src
Кроме полей, объявленными как final могут быть параметры метода и локальные переменные.
Это препядствует изменению параметра метода, тогда как аналогичное объявление локальной переменной - присвоению ей значения больше одного раза.
Ключевое слово final можно указывать и в объявлении методов. В данном случае это имеет совсем другое значение (что-то с наследованием).
** Еще раз о массивах
Размер массива хранится в его переменной экземпляра legth:
#+begin_src java
public class Length {
   public static void main(String[] args) {
      int a1[] = new int[10];
      int a2[] = {3,5,7,1,8,99,44,-10};
      int a3[] = {4,3,2,1};
      System.out.println("длина а1 равна " + a1.length);
      System.out.println("длина а2 равна " + a2.length);
      System.out.println("длина а3 равна " + a3.length);
   }
}
#+end_src
** Вложенные и внутренние классы
Вложенным называется класс, расположенный внутри другого класса.
Область действия вложенного класса ограничивается областью действия внешнего класса.
Вложенный класс имеет доступ к членам (в т.ч. закрытым) того класса, в который он вложен.
Но внешний класс не имеет доступа к членам вложенного класса.
Типы вложенных классов: статические и нестатические.
Статический вложенный класс объявляется при помощи static, и он должен обращаться только к статическим членам своего внешнего класса посредством объекта.
Внутренний класс - это нестатический вложенный класс. Он имеет доступ ко всем переменным и методам своего внешнего класса.
#+begin_src java
class Outer {
   int outer_x = 100;
   void test() {
      Inner inner = new Inner();
      inner.display();
   }

   class Inner {
      void display() {
         System.out.println("вывод: outer_x = " + outer_x);
      }
   }
}

public class InnerClassDemo {
   public static void main(String[] args) {
      Outer outer = new Outer();
      outer.test();
   }
}
#+end_src
Вложенные классы удобно использовать при обработке событий (глава 24).
** Краткий обзор класса String
Любая символьная строка как и строковая константа являются объектом класса String.
Объекты класса String являются неизменяемыми.
Если нужно изменить строку, то:
- можно создать новую;
- можно воспользоваться классами StringBuffer или StringBuilder.
#+begin_src java
public class StringDemo {
   public static void main(String[] args) {
      String strOb1 = "Первая строка";
      String strOb2 = "Вторая строка";
      String strOb3 = strOb1 + " и " + strOb2;
      System.out.println(strOb1);
      System.out.println(strOb2);
      System.out.println(strOb3);
   }
}
#+end_src
Некоторые методы класса String:
equals() - проверка двух символьных строк на равенство;
length() - вычисление длины символьной строки;
charAt() - получение символа по заданному индексу.
Общие формы:
#+begin_src java
boolean equals(вторая_строка);
int length();
char charAt(индекс);
#+end_src
Ситкаксис:
#+begin_src java
public class StringDemo {
   public static void main(String[] args) {
      String strOb1 = "Первая строка";
      String strOb2 = "Вторая строка";
      String strOb3 = strOb1;
      System.out.println("Длина строки strOb1: " + strOb1.length());
      System.out.println("Символ по индексу 3 " + " в строке strOb1: " + strOb1.charAt(3));
      if (strOb1.equals(strOb2))
         System.out.println("strOb1 == strOb2");
      else
         System.out.println("strOb1 != strOb2");
      if (strOb1.equals(strOb3))
         System.out.println("strOb1 == strOb3");
      else
         System.out.println("strOb1 != strOb3");
   }
}
#+end_src
Массивы символьных строк:
#+begin_src java
public class StringDemo {
   public static void main(String[] args) {
      String str[] = {"один", "два", "три"};
      for (int i = 0; i < str.length; i++)
         System.out.println("str[" + i + "]: " + str[i]);
   }
}
#+end_src
** Применение аргуметов командной строки
Аргумент командной строки - информация, которая во время запуска программы указывается в командной строке непосредственно после ее имени.
Аргументы командной строки хранятся в виде симольных строк в массиве типа String.
Первый аргумент командной строки хранится в элементе массива args[0], второй в элементе args[1] и т.д.
Вывод всех аргументы командной строки:
#+begin_src java
public class StringDemo {
   public static void main(String[] args) {
      for (int i = 0; i < args.length; i++)
         System.out.println("args[" + i + "]: " + args[i]);
   }
}
#+end_src
** Аргументы переменной длины
В версии JDK5 было внедрено новое языковое средство, упрощающее создание методов, принимающих переменное количество аргументов.
Оно получило название varargs (variable-length arguments - аргементы переменной длины).
До версии J2SE 5 обработка аргументов переменной длины выполнялась двумя способами:
1. Перегрузка методов;
2. Аргументы сначала размещаются в массиве, а затем массив передается методу.
   Пример:
#+begin_src java
public class PassArray {
   static void vaTest(int v[]) {
      System.out.print("Количество аргументов: " + v.length + " Содержимое: ");
      for (int x : v)
         System.out.print(x + " ");
      System.out.println();
   }

   public static void main(String[] args) {
      int n1[] = {10};
      int n2[] = {1,2,3};
      int n3[] = { };
      vaTest(n1);
      vaTest(n2);
      vaTest(n3);
   }
}
#+end_src
Этот подход требует ручного размещения аргументов в массиве до вызова методов.
Для указания аргументов переменной длины служат три точки (...)
#+begin_src java
static void vaTest(int ... v) {
#+end_src
Таким образом методу можно передавить переменной количество аргументов или вообще ничего не передаваться.
В итоге массив v неявно объявляется как массив типа int[].
В теле метода vaTest() доступ к массиву v осуществляется через синтаксим обычного массива.
#+begin_src java
public class VarArgs {
   static void vaTest(int ... v) {
      System.out.print("Количество аргументов: " + v.length + " Содержимое: ");
      for (int x : v)
         System.out.print(x + " ");
      System.out.println();
   }

   public static void main(String[] args) {
      vaTest(10);
      vaTest(1,2,3);
      vaTest();
   }
}
#+end_src
Наряду с параметрами переменной длины у метода могут быть и обычные параметры.
Но параметр переменной длины должен быть последним:
#+begin_src java
int doIt(int a, double b, int ... c) {
#+end_src
Метод должен содержать только один параметр с переменным количеством аргументов.
*** Перегрузка методов с аргументами переменной длины
Метод, принимающий аргументы переменной длины, можно перегружать.
#+begin_src java
public class VarArgs3 {
   static void vaTest(int ... v) {
      System.out.print("vaTest(int ...): "
            + "Количесвто аргументов: "
            + v.length + " Содержимое: ");
      for (int x : v)
         System.out.print(x + " ");
      System.out.println();
   }

   static void vaTest(boolean ... v) {
      System.out.print("vaTest(boolean ...): "
            + "Количесвто аргументов: "
            + v.length + " Содержимое: ");
      for (boolean x : v)
         System.out.print(x + " ");
      System.out.println();
   }

   static void vaTest(String msg, int ... v) {
      System.out.print("vaTest(String, int ...): "
            + msg + v.length + " Содержимое: ");
      for (int x : v)
         System.out.print(x + " ");
      System.out.println();
   }

   public static void main(String[] args) {
      vaTest(1,2,3);
      vaTest("Проверка", 10, 20);
      vaTest(true, false);
   }
}
#+end_src
*** Аргументы переменной длины и неоднозначность
При перегрузке метода, принимающего аргументы переменной длины, могут происходить непредвиденные ошибки.
Они связаны с неоднозначностью, которая может возникать при вызове перегружаемого метода с аргументами переменной длины.
#+begin_src java
public class StringDemo {
   static void vaTest(int ... v) {
      System.out.print("vaTest(int ...): "
            + "Количесвто аргументов: "
            + v.length + " Содержимое: ");
      for (int x : v)
         System.out.print(x + " ");
      System.out.println();
   }

   static void vaTest(boolean ... v) {
      System.out.print("vaTest(boolean ...): "
            + "Количесвто аргументов: "
            + v.length + " Содержимое: ");
      for (boolean x : v)
         System.out.print(x + " ");
      System.out.println();
   }

   public static void main(String[] args) {
      vaTest(1,2,3);
      vaTest(true, false);
      vaTest(); // ERROR!!!
   }
}
#+end_src
Еще один пример неоднозначности:
#+begin_src java
static void vaTest(int ... v) { // ...
static void vaTest(int n, int ... v) { // ...
#+end_src
Компилятор не в состоянии разрешить следующий вызов:
#+begin_src java
vaTest(1);
#+end_src

* Глава 8. Наследование
Наследуемый класс называется суперклассом, а наследующий - подклассом.
Подкласс - это специализированная версия суперкласса. Он наследует все члены, определенные в суперклассе, добавляя к ним собственные элементы.
** Основы наследования
Ключевое слово extends для наследования класса.
Общая форма наследования:
#+begin_src java
class имя_подкласса extends имя_суперкласса {
    // тело класса
}
#+end_src
#+begin_src java
class A {
   int i, j;
   void showij() {
      System.out.println("i и j: " + i + " " + j);
   }
}
class B extends A {
   int k;
   void showk() {
      System.out.println("k: " + k);
   }
   void sum() {
      System.out.println("i+j+k: " + (i+j+k));
   }
}
public class SimpleInheritance {
   public static void main(String[] args) {
      A superOb = new A();
      B subOb = new B();
      // суперкласс может использоваться самостоятельно
      superOb.i = 10;
      superOb.j = 20;
      System.out.println("Содержимое объекта superOb: ");
      superOb.showij();
      System.out.println();
      /*Подкласс имеет доступ ко всем открытым членам своего суперкласса*/
      subOb.i = 7;
      subOb.j = 8;
      subOb.k = 9;
      System.out.println("Содержимое объекта subOb: ");
      subOb.showij();
      subOb.showk();
      System.out.println();
      System.out.println("Сумма i, j и k в объекте subOb: ");
      subOb.sum();
   }
}
#+end_src
*** Доступ к членам класса и наследование
Подкласс не имеет доступ к членам суперкласса, объявленных как private.
#+begin_src java
class A {
   int i;
   private int j;
   void showij(int x, int y) {
      i = x;
      j = y;
   }
}
class B extends A {
   int total;
   void sum() {
      total = i + j; // ERROR!!!
   }
}
public class Access {
   public static void main(String[] args) {
      B subOb = new B();
      subOb.setij(10,20); // ERROR!!!
      subOb.sum();
      System.out.println("Сумма равна " + subOb.total);
   }
}
#+end_src
*** Практический пример наследования
#+begin_src java
class Box {
   double width;
   double height;
   double depth;
   // клон объекта
   Box(Box ob) {
      width = ob.width;
      height = ob.height;
      depth = ob.depth;
   }
   // все размеры
   Box(double w, double h, double d) {
      width = w;
      height = h;
      depth = d;
   }
   // отсутствие размеров
   Box() {
      width = -1;
      height = -1;
      depth = -1;
   }
   // куб
   Box(double len) {
      width = height = depth = len;
   }
   // расчет и возврат объема
   double volume() {
      return width * height * depth;
   }
}
class BoxWeight extends Box {
   double weight;
   BoxWeight(double w, double h, double d, double m) {
      width = w;
      height = h;
      depth = d;
      weight = m;
   }
}
public class DemoBoxWeight {
   public static void main(String[] args) {
      BoxWeight mybox1 = new BoxWeight(10,20,15,34.3);
      BoxWeight mybox2 = new BoxWeight(2,3,4,0.076);
      double vol;
      vol = mybox1.volume();
      System.out.println(vol);
      System.out.println(mybox1.weight);
      vol = mybox2.volume();
      System.out.println(vol);
      System.out.println(mybox2.weight);
   }
}
#+end_src
*** Переменная из суперкласса может ссылаться на объект подкласса
Ссылочной переменной из суперкласса может быть присвоена ссылка на любой подкласс, производный от этого суперкласса.
#+begin_src java
public class DemoBoxWeight {
   public static void main(String[] args) {
      BoxWeight weightbox = new BoxWeight(3,5,7,8.37);
      Box plainbox = new Box();
      double vol;
      vol = weightbox.volume();
      System.out.println("Объем weightbox равен " + vol);
      System.out.println("Вес weightbox раве " + weightbox.weight);
      // присвоить переменной ссылки на объект типа BoxWeight
      // ссылку на объект типа Box
      plainbox = weightbox;
      vol = plainbox.volume(); // Верно, т.к. метод volume()
                              // определен в классе Box
      System.out.println("Объем plainbox равен " + vol);
      /*Следующий оператор ошибочен, поскольку член plainbox
      * не определяет член weight*/
      System.out.println("Вес plainbox равер " + plainbox.weight);
   }
}
#+end_src
Объекту типа суперкласса (plainbox) можно присвоить ссылку на объект типа подкласса (weightbox).
** Ключевое слово super
С помощью ключевого слова super подклассу представляется возможность сосласться на его непосредственный суперкласс.
У ключевого слова super имеются две общие формы. Первая форма служит для вызова конструктора суперкласса.
Вторая - для обращения к члену суперкласса, скрываемому членом подкласса.
*** Вызов конструкторов суперкласса и помощью ключевого слова super
Из подкласса можно вызвать конструктор, определенный в его суперклассе:
#+begin_src java
super(список_аргументов);
#+end_src
Вызов super(); дожен находиться в первом операторе, выполняемом в конструкторе подкласса.
#+begin_src java
class BoxWeight extends Box {
   double weight;
   BoxWeight(double w, double h, double d, double m) {
      super(w,h,d);
      weight = m;
   }
}
#+end_src
Конструкторы могут быть перегружаемыми, поэтому метод super() можно вызывать, используя любую форму, определенную в суперклассе.
#+begin_src java
class Box {
   private double width;
   private double height;
   private double depth;
   // клон объекта
   Box(Box ob) {
      width = ob.width;
      height = ob.height;
      depth = ob.depth;
   }
   // все размеры
   Box(double w, double h, double d) {
      width = w;
      height = h;
      depth = d;
   }
   // отсутствие размеров
   Box() {
      width = -1;
      height = -1;
      depth = -1;
   }
   // куб
   Box(double len) {
      width = height = depth = len;
   }
   // расчет и возврат объема
   double volume() {
      return width * height * depth;
   }
}
class BoxWeight extends Box {
   double weight;
   // сконструировать клон объекта
   BoxWeight(BoxWeight ob) {
      super(ob);
      weight = ob.weight;
   }
   // все параметры
   BoxWeight(double w, double h, double d, double m) {
      super(w,h,d);
      weight = m;
   }
   // конструктор по умолчанию
   BoxWeight() {
      super();
      weight = -1;
   }
   // конструктор для куба
   BoxWeight(double len, double m) {
      super(len);
      weight = m;
   }
}
#+end_src
Несмотря на то, что методу super() передается объект типа BoxWeight, а не Box, это все равно приводить к вызову конструктора Box(Box.ob).
#+begin_src java
BoxWeight(BoxWeight ob) {
   super(ob);
   weight = ob.weight;
}
#+end_src
При вызове метода super() из подкласса вызывается конструктор его непосредственного суперкласса (на один выше).
Это справледливо также для многоуровневой иерархии.
*** Другое применение ключевого слова super
Вторая форма ключевого слова super действует подобно ключевому слову this, за исключением того, что ссылка всегда делается на суперкласс того подкласса, в котором используется super.
Общая форма применения:
#+begin_src java
super.член // член - переменная экземпляра или метод
#+end_src
Применяется когда имена членов подкласса скрывают члены суперкласса с такими же именами.
#+begin_src java
class A {
   int i;
}

class B extends A {
   int i; // этот член i  скрывает член i из класса А

   B(int a, int b) {
      super.i = a;   // член i  из класса А
      i = b;         // член i  из класса В
   }
   void show() {
      System.out.println("Член i в суперклассе: " + super.i);
      System.out.println("Член i в подклассе: " + i);
   }
}

public class UseSuper {
   public static void main(String[] args) {
      B subOb = new B(1,2);
      subOb.show();
   }
}
#+end_src
** Создание многоуровневой иерархии
Создание иерархий, состоящей из нескольких уровней наследования (много классов, наследуемых по иерархии).
** Порядок вызова конструкторов
В иерархии классов конструкторы вызываются в порядке наследования, начиная с суперкласса и кончая подклассом.
** Переопределение методов
Если в иерархии классов совпадают имена и сигнатуры типов методов из подкласса и суперкласса, то метод из подкласса переопределяет метод из суперкласса. При вызовер переопределенного метода из подкласса, он всегда ссылается на свой вариант, определенный в подклассе. А вариант метода, определенный в суперклассе, будет скрыт.
Пример:
#+begin_src java
class A {
   int i, j;
   A(int a, int b) {
      i = a;
      j = b;
   }
   void show() {
      System.out.println("i и j: " + i + " " + j);
   }
}
class B extends A {
   int k;
   B(int a, int b, int c) {
      super(a, b);
      k = c;
   }
   void show() {
      System.out.println("k: " + k);
   }
}
public class Override {
   public static void main(String[] args) {
      B subOb = new B(1,2,3);
      subOb.show();
   }
}
// результат: k: 3
#+end_src
Если нужно получить доступ к варианту переопределенного метода из суперкласса, то с помощью super:
#+begin_src java
class B extends A {
   int k;
   B(int a, int b, int c) {
      super(a, b);
      k = c;
   }
   void show() {
      super.show();
      System.out.println("k: " + k);
   }
}
// результат
// i и j: 1 2
// k: 3
#+end_src
Переопределение методов выполняется только в том случае, если имена и сигнатуры типов обоих методов одинаковы.
В противном случае методы считаются перегруженными.
** Динамическая диспетчеризация методов
Переопределение методов служит основой для реализации одного из самых эффективных принципов - динамической диспетчеризации методов (ДДМ).
ДДМ это механизм, с помощью которого вызов переопределенного метода разрешается во время выполнения, а не компиляции.
ДДМ важна потому, что благодаря ей полиморфизм в Java реализуется во время выполнения.
Ссылочной переменной из суперкласса может быть присвоена ссылка на любой подкласс, производный от этого суперкласса:
Этот принцип используется в Java для разрешения вызовов переопределенных методов во время выполнения следующим образом:
когда переопределенный метод вызывается по ссылке на суперкласс, нужный вариант этого метода выбирается в Java в зависимости от типа объекта, на который делается ссылка в момент вызова. Следовательно, этот выбор делается во время выполнения.
Иначе говоря, вариант переопределенного метода выбирается для выполнения в зависимости от типа объекта, на который делается ссылка.
#+begin_src java
class A {
   void callMe() {
      System.out.println("В методе callMe() из класса А");
   }
}
class B extends A {
   void callMe() {
      System.out.println("В методе callMe() из класса B");
   }
}
class C extends A {
   void callMe() {
      System.out.println("В методе callMe() из класса C");
   }
}
public class Dispatch {
   public static void main(String[] args) {
      A a = new A(); // объект класса А
      B b = new B(); // объект класса В
      C c = new C(); // объект класса С

      A r;        // объявление ссылки r на объект типа А

      r = a;      // переменная r ссылается на объект типа А
      r.callMe(); // вызвать вариает метода callMe(), определенный в классе А

      r = b;      // переменная r ссылается на объект типа B
      r.callMe(); // вызвать вариает метода callMe(), определенный в классе B

      r = c;      // переменная r ссылается на объект типа C
      r.callMe(); // вызвать вариает метода callMe(), определенный в классе C
   }
}
#+end_src
*** Назначение переопределенных методов
Переопределенные методы позволяют поддерживать в Java полиморфизм во время выполнения.
Полиморфизм позволяет определить в общем классе методы, которые станут общими для всех производных от него классов, а в подклассах - конкректные реализации некоторых или всех этих методов.
Переопределенные методы - это один из способов в Java реализации полиморфизма.
Условием успешного применения полиморфизма является понимание, что суперклассы и подклассы образуют иерархию по степени увеличения специализации.
*** Применение переопределенных методов
#+begin_src java
class Figure {
   double dim1;
   double dim2;
   Figure(double a, double b) {
      dim1 = a;
      dim2 = b;
   }
   double area() {
      System.out.println("Площадь фигуры не определена.");
      return 0;
   }
}
class Rectange extends Figure {
   Rectange(double a, double b) {
      super(a, b);
   }
   // переопределить метод area() для четырехугольника
   double area() {
      System.out.println("В области четырехугольника");
      return dim1 * dim2;
   }
}
class Triangle extends Figure {
   Triangle(double a, double b) {
      super(a, b);
   }
   double area() {
      System.out.println("В области треугольника.");
      return dim1 * dim2 / 2;
   }
}
public class FindAreas {
   public static void main(String[] args) {
      Figure f = new Figure(10,10);
      Rectange r = new Rectange(9,5);
      Triangle t = new Triangle(10,8);
      Figure figref;
      figref = r;
      System.out.println(figref.area());
      figref = t;
      System.out.println(figref.area());
      figref = f;
      System.out.println(figref.area());
   }
}
#+end_src
** Применение абстрактных классов
Абстрактный класс содержит обобщенную форму для совместного использования всеми его подклассами.
В таком классе определяется характер методов, которые должны быть реализованы в подклассах, без возможности их использвания.
Такой метод называется абстрактным. Абстрактный метод используется также для проверки его переопределения.
Объявление абстрактного метода:
#+begin_src java
abstract имя_метода(список_параметров);
#+end_src
Любой класс, содержащий один или несколько абстрактных методов, должен быть также объявлен как абстрактный.
У абстрактного класса не может быть никакаих объектов. Это обзначает, что экземпляр абстрактного класса не может быть получен с помощью оператора new. Также нельзя объявлять абстрактные конструкторы или абстрактные статические методы.
Любой подкласс, производный от абстрактного класса, должен реализовать все абстрактные методы из супрекласса или же сам быть объявлен абстрактными.
#+begin_src java
abstract class A {
   abstract void callme();
   // абстрактные классы все же могут содержать конкректные методы
   void callmetoo() {
      System.out.println("Это конкретный метод.");
   }
}
class B extends A {
   void callme() {
      System.out.println("Реализация метода callme() в классе В");
   }
}
public class AbstractDemo {
   public static void main(String[] args) {
      B b = new B();
      b.callme();
      b.callmetoo();
   }
}
#+end_src
Несмотря на то, что нельзя создать объект на основе абстрактного класса, их можно применять для создания ссылок на объекты, поскольку в Java полиморфизм во время выполнения реализован с помощью ссылок на суперкласс.
#+begin_src java
abstract class Figure {
   double dim1;
   double dim2;
   Figure(double dim1, double dim2) {
      this.dim1 = dim1;
      this.dim2 = dim2;
   }
   abstract double area();
}
class Rectangle extends Figure {
   Rectangle(double dim1, double dim2) {
      super(dim1, dim2);
   }
   double area() {
      System.out.println("В области четырехугольника");
      return dim1 * dim2;
   }
}
class Triangle extends Figure {
   Triangle(double dim1, double dim2) {
      super(dim1, dim2);
   }
   double area() {
      System.out.println("В области треугольника");
      return dim1 * dim2 / 2;
   }
}

public class AbstractAreas {
   public static void main(String[] args) {
      Rectangle r = new Rectangle(9,5);
      Triangle t = new Triangle(10,8);
      Figure f;
      f = r;
      System.out.println(f.area());
      f = t;
      System.out.println(t.area());
   }
}
#+end_src
** Ключевое слово final в сочетании с наследованием
Ключевое слово final можно использовать тремя способами.
Первый из них применяется для создания констант.
Второй и третий способы относятся к наследованию.
*** Предотвращение переопределения с помощью ключевого слова final
Для запрета переопределения метода, в начале его объявления следует указать final.
#+begin_src java
class A {
    final void meth() {
        System.out.println("Конечный метод");
    }
}
#+end_src
Методы, объявленные как final, переопределятся не могут.
Иногда методы, объявленные как final, могут способствовать увеличению производительности.
Обычно, вызовы методов разрешаются в Java динамически во время выполнения (ПОЗДНЕЕ СВЯЗЫВАНИЕ).
Но поскольку конечные методы не могут быть переопределены, их вызовы могут быть разрешены во время компиляции (РАННЕЕ СВЯЗЫВАНИЕ).
*** Предотвращение наследования с помощью ключевого слова final
Запрет наследования классов с помощью final
#+begin_src java
final class A {
    // тело класса
}
#+end_src
** Класс Object
Класс Object - это суперкласс для всех остальных классов в Java.
Ссылочная переменная из класса Object может ссылаться на объект любого другого класса. А поскольку массивы реализованы в виде классов, то ссылочная переменная типа Object может ссылается и на любой массив.
Методы класса Object:
#+begin_src java
Object clone() // создает новый объект, не отличающийся от клонируемого
boolean equals(Object object) // определят, равен ли один объект другому
void finalize() // вызывает перед удалением неиспользуемого объекта (не рекомендован для применения с JDK 9)
Class<?> getClass() // получает класс объекта во время выполнения
int hasghCode() // Возвращает хэш-код, связанный с вызывающим объектом
void notify() // возобновляет исполнение потока, ожидающего вызывающего объекта
void nofifyAll() // возобновляет исполнение всех потоков, ожидающих вызывающий объект
String toString() // возвращает символьную строку, описывающую объект
void wait() // ожидает другого потока исполнения
void wait(long милисекунд)
void wait(lond милисекунд, int наносекунд)
#+end_src
Методы getClass(), notify(), nofifyAll() и wait() объявлены как final.

* Глава 9. Пакеты и интерфейсы
Пакеты являются контейнерами классов. Они служат для разделения пространств имен класса.
С помощью ключевого слова interface в Java можно полностью абстрагировать интерфейс класса от его реализации.
Отличие от абстрактных классов - возможность реализовать в одном классе несколько интерфейсов.
** Пакеты
*** Опеределение пакета
#+begin_src java
package имя_пакетаж;
#+end_src
Для хранения пакетов в Java используются каталоги файловой системы.
Допускается создавать иерархию пакетов:
#+begin_src java
package a.b.c; // ~/project/a/b/c
#+end_src
*** Поиск пакетов и переменная окружения CLASSPATH
Как Java ищет создаваемые пакеты (3 варианта)?
1. Рабочий каталог проекта;
2. Установка переменной окружения CLASSPATH;
3. Установка пути к классам в командной строке с помощью опции -classpath.
*** Краткий пример пакета
#+begin_src java
package mypack;

class Balance {
   String name;
   double bal;
   Balance(String name, double bal) {
      this.name = name;
      this.bal = bal;
   }
   void show() {
      if (bal > 0)
         System.out.print("--> ");
      System.out.println(name + ": $" + bal);
   }
}

public class AccountBalance {
   public static void main(String[] args) {
      Balance current[] = new Balance[3];
      current[0] = new Balance("string1", 123.33);
      current[1] = new Balance("string2", 157.02);
      current[2] = new Balance("string3", -12.33);
      for (int i = 0; i < 3; i++)
         current[i].show();
   }
}
#+end_src
** Доступ к пакетам и их компонентам
Пакеты расширяют возможности управления доступом.
Классы и пакеты одновременно служат для инкапсуляции и обозначения пространства имен и области видимости переменных и методов.
Характер взаимодействия пакетов и классов в Java определяет 4 категории доступности членов класса.:
- подклассы из одного пакета;
- классы из одного пакета, не являющиеся подклассами;
- подклассы из разных пакетов;
- классы, не относящиеся к одному пакету и не являющиеся подклассами.
Модификаторы доступа private, public, protected обеспечивают различные способы создания уровней доступа.
Если требуется, чтобы компонент был доступен за пределами его текущего пакета, но только классам, непосредственно производным от данного класса, то protected.
*** Пример доступа к пакетам
Проект с директориями:
../p1/*.java
#+begin_src java
// ../p1/Protection.java
package p1;

public class Protection {
   int n = 1;
   private int n_pri = 2;
   protected int n_pro = 3;
   public int n_pub = 4;
   public Protection() {
      System.out.println("конструктор базового класса");
      System.out.println("n = " + n);
      System.out.println("n_pri = " + n_pri);
      System.out.println("n_pro = " + n_pro);
      System.out.println("n_pub = " + n_pub);
   }
}

// ../p1/Derived.java
package p1;

public class Derived extends Protection{
   Derived() {
      System.out.println("конструктор подкласса");
      System.out.println("n = " + n);
      // доступно только для класса
      // System.out.println("n_pri = " + n_pri);
      System.out.println("n_pro = " + n_pro);
      System.out.println("n_pub = " + n_pub);
   }
}

// ../p1/SamePackage.java
package p1;

public class SamePackage {
   SamePackage() {
      Protection p = new Protection();
      System.out.println("конструктор из того же самого пакета");
      System.out.println("n = " + p.n);
      // доступно только для класса
      // System.out.println("n_pri = " + p.n_pri);
      System.out.println("n_pro = " + p.n_pro);
      System.out.println("n_pub = " + p.n_pub);
   }
}

// ../p1/Demo.java
package p1;

public class Demo {
   public static void main(String[] args) {
      Protection ob1 = new Protection();
      Derived ob2 = new Derived();
      SamePackage ob3 = new SamePackage();
   }
}
#+end_src
../p2/*.java
#+begin_src java
// ../p2/Protection2.java
package p2;

public class Protection2 extends p1.Protection{
   Protection2() {
      System.out.println("конструктор, унаследованный из другого пакета");
      // доступно толлько для данного класса
      // System.out.println("n_pri = " + n_pri);
      System.out.println("n_pro = " + n_pro);
      System.out.println("n_pub = " + n_pub);
   }
}

// ../p2/OtherPackage
package p2;

public class OtherPackage {
   OtherPackage() {
      p1.Protection p = new p1.Protection();
      System.out.println("конструктор из другого пакета");

      // доступно только для данного класса или пакета
      // System.out.println("n = " + p.n);

      // доступно только для данного класса
      // System.out.println("n_pri = " + p.n_pri);

      // доступно только для данного класса, подкласса или пакета
      // System.out.println("n_pro = " + p.n_pro);
      System.out.println("n_pub = " + p.n_pub);
   }
}

// ../p2/Demo.java
package p2;

public class Demo {
   public static void main(String[] args) {
      Protection2 ob1 = new Protection2();
      OtherPackage ob2 = new OtherPackage();
   }
}
#+end_src
** Импорт пакетов
Ни один из основных пакетов Java не хранится в неименованном пакете, используемом по умолчанию.
Чтобы отдельные классы или весь пакет можно было сделать доступным, в Java введен оператор import.
В исходном коде оператор import должен следовать сразу за оператором package и перед любыми определениями классов.
Общая форма импорта класса:
#+begin_src java
import пакет1.пакет2.имя_класса;
#+end_src
Если необходимо импортировать весь пакет, то:
#+begin_src java
import пакет1.пакет2.*;
#+end_src
Все классы стандартной библиотеки хранятся в пакете java.
При импорте пакета классам, не производным от классов из данного пакета в импортирующем коде, будут доступны только те элементы пакета, которые объявлены как public.
#+begin_src java
// ../mypack/Balance.java
package mypack;

public class Balance {
   String name;
   double bal;

   public Balance(String name, double bal) {
      this.name = name;
      this.bal = bal;
   }
   public void show() {
      if (bal < 0)
         System.out.print("--> ");
      System.out.println(name + ": $" + bal);
   }
}

// ../TestBalance.java
import mypack.*;

public class TestBalance {
   public static void main(String[] args) {
      Balance test = new Balance("string1", 99.88);
      test.show();
   }
}
#+end_src
** Интерфейсы
С помощью ключевого слова interface можно полностью абстрагировать интерфейс класса от его реализации, т.е. указать, что именно должен выполнять класс, но не как это делать.
Синтаксически интерфейсы аналогичны классам, но не содержат переменные экземпляра, а объявления их методов, как правило, не содержат тело метода.
Ключевое слово interface позволяет в полной мере использовать принцип полиморфизма.
Интерфейсы предназначены для поддержки динамического разрешения вызовов методов во время выполнения.
*** Объявление интерфейса
Общая форма интерфейса:
#+begin_src java
модификатор_доступа interface имя {
    тип имя_метода(список_параметров);
    тип имя_переменной = значение;
}
#+end_src
Если определение не содержит никакого модификатора доступа, используется доступ по умолчанию, а интерфейс доступен только другим членам этого пакета.
Если интерфейс объявлен как public, он может быть использован в любом другом коде. В этом случае интерфейс должен быть единственным открытым интерфейсом, объявленным в файле, а имя этого файла должно совпадать с именем интерфейса.
Каждый класс, который включает в себя интерфейс, должен реализовать все его методы.
Переменные, объявленные в интерфейсе, неявно объявляются как final и static, т.е. их нельзя изменить в классе.
Кроме того, они должны быть инициализированы.
Пример интерфейса:
#+begin_src java
interface Callback {
    void callback(int param);
}
#+end_src
*** Реализация интерфейсов
Реализация интерфейсов в классе:
#+begin_src java
модификатор_доступа class имя_класса extends суперкласс implements интерфейс {
    // тело класса
}
#+end_src
Методы, релизующие элементы интерфейса, должны быть объявлены как public.
#+begin_src java
class Client implements Callback {
    public void callback(int p) {
        System.out.println(p);
    }
    void nonIfaceMeth() {
        System.out.println("some text");
    }
}
#+end_src
Классы, реализующие интерфейсы, могут содержать собственные члены (nonIfaceMeth()).
**** Доступ к реализациям через ссылки на интерфейсы
Переменные можно объявлять как ссылки на объекты, в которых используется тип интерфейса, а не тип класса.
С помощью такой переменной можно ссылаться на любой экземпляр какого угодно класса, реализующего объявленный интерфейс.
При вызове метода по одной из таких ссылок нужный вариант будет выбиратся в зависимости от конкретного экземпляра интерфейса, на который делается ссылка. Это одна из главных особенностей интерфейсов. Поиск исполняемого метода осуществляется динамически во время выполнения, что позволяет создать классы позднее, чем код, из которого вызываются методы этих классов.
Вызывающий код может выполнять ДДМ с помощью интерфейса, даже не имея никаких сведений о вызываемом коде. Этот процесс аналогичен использованию ссылки на суперкласс для доступа к объекту подкласса.
Пример:
#+begin_src java
class TestIface {
    public static void main(String[] args) {
        Callback c = new Client();
        c.callback(42);
    }
}
#+end_src
Переменной c присвоен экземпляр класса Client, несмотря на то, что она была объявлена с типом интерфейса Callback.
Переменная c имеет доступ только к методам (callback()), объявленным в интерфейсе, на который она ссылается (Callback).
Но она не предоставляет доступа к каким-нибудь другим членам класса Client (метод nonIfaceMeth()).
Демонстрация полиморфизма переменных ссылок на интерфейс:
#+begin_src java
public class AnotherClinet implements Callback{
   public void callback(int p) {
      System.out.println("Еще один вариант метода callback()");
      System.out.println("p в кладрате равно " + p * p);
   }
}

class Client implements Callback {
   public void callback(int p) {
      System.out.println("Метод callback(), вызваемый со значением " + p);
   }
   void nonIfaceMeth() {
      System.out.println("some text");
   }
}

class TestIface2 {
   public static void main(String[] args) {
      Callback c = new Client();
      AnotherClinet ob = new AnotherClinet();
      c.callback(42);
      c = ob;
      c.callback(42);
   }
}
#+end_src
*** Вложенные интерфейсы
*** Применение интерфейсов
*** Переменные в интерфейсах
*** Расширение интерфейсов
** Методы с реализацией по умолчанию
*** Основные применения методов с реализацией по умолчанию
*** Прикладной пример
*** Вопросы множественного наследования
** Применение статических методов в интерфейсе
** Закрытые методы интерфейсов
** Заключительные соображения по поводу пакетов и интерфейсов
